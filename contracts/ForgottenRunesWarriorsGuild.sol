pragma solidity ^0.8.0;

import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
import '@openzeppelin/contracts/security/ReentrancyGuard.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import './interfaces/IForgottenRunesWarriorsGuild.sol';

/**
 * @dev This implements the tokens of the Forgotten Runes Warriors Guild. They are {ERC721} tokens.
 */
contract ForgottenRunesWarriorsGuild is
    IForgottenRunesWarriorsGuild,
    Ownable,
    ReentrancyGuard,
    ERC721
{
    using Strings for uint256;

    /// @notice The maximum number of Warriors
    uint256 public constant MAX_WARRIORS = 16000;

    /// @notice Counter to track the number minted so far
    uint256 public numMinted = 0;

    /// @notice Address of the minter
    address public minter;

    /// @notice The base URI for the metadata of the tokens
    string public baseTokenURI;

    string public constant R =
        "Old men forget: yet all shall be forgot, But he'll remember with advantages What feats he did that day: then shall our names Familiar in his mouth as household words. This story shall the good man teach his son From this day to the ending of the world";

    /// @notice The provenance hash
    string public METADATA_PROVENANCE_HASH = '';

    /**
     * @dev Create the contract and set the initial baseURI
     * @param baseURI string the initial base URI for the token metadata URL
     */
    constructor(string memory baseURI)
        ERC721('ForgottenRunesWarriorsGuild', 'WARRIORS')
    {
        setBaseURI(baseURI);
    }

    /**
     * @dev Convenient way to initialize the contract
     * @param newMinter address of the minter contract
     */
    function initialize(address newMinter) public onlyOwner {
        setMinter(newMinter);
    }

    /**
     * @dev Returns the URL of a given tokenId
     * @param tokenId uint256 ID of the token to be minted
     * @return string the URL of a given tokenId
     */
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(tokenId),
            'ERC721Metadata: URI query for nonexistent token'
        );

        return string(abi.encodePacked(baseTokenURI, tokenId.toString()));
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseTokenURI;
    }

    /**
     * @dev Returns if the token exists
     * @param tokenId uint256 the id of the token
     * @return exists bool if it exists
     */
    function exists(uint256 tokenId) public view returns (bool) {
        return _exists(tokenId);
    }

    /**
     * @dev Mint the next token
     * @param recipient address representing the owner of the new tokenId
     * @return tokenId uint256 the new tokenId
     */
    function mint(address recipient)
        public
        override
        nonReentrant
        returns (uint256)
    {
        require(numMinted < MAX_WARRIORS, 'All warriors have been summoned');
        require(_msgSender() == minter, 'Not a minter');
        uint256 tokenId = numMinted;
        _mint(recipient, tokenId);
        numMinted += 1;
        return tokenId;
    }

    /**
     * @notice I wouldn't if I were you
     * @dev Burns the token
     * @param tokenId uint256 representing the tokenId
     */
    function burn(uint256 tokenId) public virtual {
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            'ERC721Burnable: caller is not owner nor approved'
        );
        _burn(tokenId);
    }

    /**
     * Only the owner can do these things
     */

    /**
     * @dev Sets a new base URI
     * @param newBaseURI string the new token base URI
     */
    function setBaseURI(string memory newBaseURI) public onlyOwner {
        baseTokenURI = newBaseURI;
    }

    /**
     * @dev Sets a new primary minter address
     * @param newMinter address of the new minter
     */
    function setMinter(address newMinter) public onlyOwner {
        minter = newMinter;
    }

    /**
     * @dev Sets provenance hash
     * @param newHash string of the new minter
     */
    function setProvenanceHash(string memory newHash) public onlyOwner {
        METADATA_PROVENANCE_HASH = newHash;
    }

    /**
     * @dev Adds calldata on chain for the images. See: https://www.forgottenrunes.com/posts/on-chain
     */
    function uploadImage(bytes calldata s) external onlyOwner {}

    /**
     * @dev Adds calldata on chain for the attributes. See: https://www.forgottenrunes.com/posts/on-chain
     */
    function uploadAttributes(bytes calldata s) external onlyOwner {}

    /**
     * @dev ETH should not be sent to this contract, but in the case that it is
     * sent by accident, this function allows the owner to withdraw it.
     */
    function withdrawAll() public payable onlyOwner {
        require(payable(msg.sender).send(address(this).balance));
    }

    /**
     * @dev Again, ERC20s should not be sent to this contract, but if someone
     * does, it's nice to be able to recover them
     * @param token IERC20 the token address
     * @param amount uint256 the amount to send
     */
    function forwardERC20s(IERC20 token, uint256 amount) public onlyOwner {
        require(address(msg.sender) != address(0));
        token.transfer(msg.sender, amount);
    }
}
